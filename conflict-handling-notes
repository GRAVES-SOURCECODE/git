===========================================================================
Special conflict types
===========================================================================

Cases (special conflict markers for path-based conflicts):
  * binary edit/edit (or add/add)
  * symlink edit/edit (or add/add)
  * mode conflict involving regular file
  * different types conflict (symlink/file, symlink/submodule)

  * modify/delete
  * rename/delete

  * add/add
  * rename/add
  * rename/rename(2to1)/delete[/delete]

  * rename/add/delete
  * rename/rename(1to2)[/add[/add]]

  * directory/file
  * file/submodule
  * directory/submodule
  * submodule/submodule

  * path in way of directory rename
  * multiple colliding paths due to directory rename
  * indeterminate split for directory rename
  * multiply-transitive renames (not a conflict, so shouldn't modify)

===========================================================================
Attempting to determining conflict types from the index
===========================================================================

Different index types and their mapping to conflicts
  !O!A!B -- doesn't exist
  !O!A B -- one-sided add
  !O A!B -- one-sided add
  !O A B -- file collision
   O!A!B -- both deleted
   O!A B -- one-sided delete
   O A!B -- one-sided delete
   O A B -- double edit

  doesn't exist:    <irrelevant>
  one-sided add:       directory/file
                    or rename/rename(1to2)
  file collision:      add/add
                    or rename/add
                    or rename/rename(2to1)
                    or rename/add from rename/rename(1to2)/add[/add]
                    or rename/rename(2to1)/delete[/delete]
  both deleted:     <irrelevant> (shouldn't happen, except r/r(1to2) bug)
  one-sided delete:    modify/delete
                    or rename/delete
  double edit:         normal edit/edit
                    or rename/add/delete ?
                    or maybe D/F if F comes from rename

===========================================================================
Directory/file conflicts pain
===========================================================================

$ git mv foo other                      # Moves the directory instead

$ mv foo~BRANCH other && git add other  # Leaves bad 'foo' unstaged

$ git mv foo~BRANCH other               # "Not under source control"

$ git add -u                            # Removes file, leaves untracked around

$ git rm foo                            # Doesn't work
foo: needs merge
rm 'foo'
fatal: git rm: 'foo': Is a directory

$ git rm --cached foo                   # Works, but throws error
foo: needs merge
rm 'foo'

mv foo~HEAD other && git add .          # This works, oddly enough


===========================================================================
TODO
===========================================================================

* Random additional fixups
  * R/R(1to2) -> merge files first, put in both places, remove the source file
* specialized renaming
  * {Dir or Submodule}/File (whether F from rename or not): rename the file
  * directories (directory/submodule)
  * submodule?? (submodule/submodule)
* conflict markers
  * in files that can handle it (mod/del, ren/del, collision types, dir/file,
                                 submod/file, mode conflicts w/ regular file)
  * when we don't have good path? (dir/submod, submod/submod, binaries,
                                   symlinks, mode conflicts w/o regular file,
                                   directory rename cases)

===========================================================================
Cover letter draft -- old version, rejected
===========================================================================

Subject: [WIP/RFC/PATCH] Facilitate directory/file conflict resolution for users

Directory/file conflicts are somewhat difficult to resolve, for
reasons I'll list below.  This patch series proposes an idea for
modifying how we handle them, in order to simplify the resolution
process for end users.

Unfortunately, it takes a bit of explanation to understand the
purpose of the modification...

== Rename analogy ==

First, I'd like to start with an analogy.  If one side of history renames
A->B but there are content conflicts, one choice for the contents for the
index would be:
  <mode> <original sha> 1    A
  <mode> <side-one sha> 2    A
  <mode> <side-two sha> 3    B
However, that's not what git does.  In particular, this choice would require
the user to run both 'git add B' and 'git rm --cached A' to resolve the
conflict.  Further, it prevents the user from running commands such as
  - git checkout -m B
  - git diff --base B
and also would make it harder to pair up entries from 'git ls-files -u'
(especially if there are many entries between A and B), since nothing marks
them as related anymore.  So, instead, git records the following in the
index:
  <mode> <original sha> 1    B
  <mode> <side-one sha> 2    B
  <mode> <side-two sha> 3    B
This might be seen as a lie, but is far more convenient for the user to
work with.


== Difficulties with resolving directory/file conflicts ==

-----

FIXME: Separate section for what git reports and how it can scroll off
the screen?  ...and how the index isn't sufficient to determine that
it is a D/F conflict, because it could be a r/r(1to2) conflict?

-----

Let's say there's a directory/file conflict for path 'foo'.  One might see
git report:
  CONFLICT (file/directory): There is a directory with name foo in...
  BRANCH2. Adding foo as foo~BRANCH
and git will record:
  * foo~BRANCH in the working tree
  * foo at higher order stage in the index
  * foo/ in the working tree
  * foo/* entries found in the index
Let's say the user wants to resolve by just moving 'foo' to somewhere
else.  Here's some things a user might try:

$ git mv foo other
  # Moves the directory instead, oops

$ mv foo~BRANCH other
$ git add other
  # Still leaves 'foo' conflicted in the index

$ git mv foo~BRANCH other
  # Error: "Not under source control"

$ git add -u
  # Removes conflict entry for 'foo' from index, but doesn't add
  # new one and leaves foo~BRANCH around untracked

$ git rm foo
  # Doesn't work ("foo: needs merge...fatal: git rm: 'foo': Is a directory)

What the user needs to do:
$ mv foo~BRANCH other
$ git add other
$ git rm --cached foo

or, possibly -- assuming EVERYTHING else in the working tree is in order:
$ mv foo~BRANCH other
$ git add .


***************************************************************************

WIP/RFC/PATCH: Modify handling of directory/file conflicts

Directory/file conflicts are more difficult than they need to be for users
to resolve (and to un-resolve).  Simplify that process by doing to the
index what we do to the working tree: renaming the file in the
directory/file conflict to a different location.  This also avoids leaving
cruft untracked files around if the user decides to abort the merge.

From one angle this proposal might appear surprising, so extended rationale
for this change can be found below...

== What git does, prior to this series ==

Let's say there's a directory/file conflict for path 'foo'.  One might see
git report:
  CONFLICT (file/directory): There is a directory with name foo in
  BRANCH2. Adding foo as foo~BRANCH
Further, at this point, git will record:
  * foo~BRANCH in the working tree
  * foo/ in the working tree
  * foo at higher order stage in the index
  * foo/* entries found in the index (at stage 0)

== User experience resolving directory/file conflicts ==

Let's say the user wants to resolve by just moving 'foo' (the file) to
somewhere else.  Here's five different things a user might try at this
point (not sequentially, but rather competing ideas they might try),
along with commentary about how each fails to resolve the conflict:

$ git mv foo other
  # Moves the directory instead, oops

$ mv foo~BRANCH other
$ git add other
  # Still leaves 'foo' conflicted in the index

$ git mv foo~BRANCH other
  # Error: "Not under source control"

$ git add -u
  # Removes conflict entry for 'foo' from index, but doesn't add
  # new one and leaves foo~BRANCH around untracked

$ git rm foo
  # Doesn't work ("foo: needs merge...fatal: git rm: 'foo': Is a directory)

== User experience un-resolving directory/file conflict ==

If the user decides they don't like the merge and run 'git merge --abort',
the abort fails due to a separate bug being fixed here:

  https://public-inbox.org/git/20180713163331.22446-1-newren@gmail.com/

However, even once the fixes there are part of git, a 'git merge --abort'
will leave behind new untracked files that were created by the merge
attempt (in the case above, one named foo~BRANCH).  This is suboptimal.

== Correct solution; old and new ==

Currently, this is what a user needs to run to resolve this conflict:

$ mv foo~BRANCH other
$ git add other
$ git rm --cached foo

If git would record foo~BRANCH at a higher stage in the index instead
of recording foo there, then we could shorten this to:

$ git add foo~BRANCH
$ git mv foo~BRANCH other

If we could also teach git-mv to quit reporting "not under version
control" for index entries with higher order stages (and instead rename
them while keeping them as higher order stages), then we could also allow
those two commands to be reversed:

$ git mv foo~BRANCH other
$ git add other

While this change to what git records in the index might feel like a lie,
it does make it easier for the user and we already have a precedent for
treating user convience as more important than trying to represent how we
got to the current state, as shown in the following analogy:

== Rename analogy ==

If one side of history renames A->B but there are content conflicts, one
choice for the contents for the index would be:
  <mode> <original sha> 1    A
  <mode> <side-one sha> 2    A
  <mode> <side-two sha> 3    B
However, that's not what git does.  In particular, this choice would require
the user to run both 'git add B' and 'git rm --cached A' to resolve the
conflict.  Further, it prevents the user from running commands such as
  git checkout [--ours|--theirs|--conflict|-m] B
  git diff [--ours|--theirs|--base] B
This would also make it harder to pair up entries from 'git ls-files -u'
(especially if there are many entries between A and B), since nothing
marks them as related anymore.  So, instead, git records the following in
the index:
  <mode> <original sha> 1    B
  <mode> <side-one sha> 2    B
  <mode> <side-two sha> 3    B
This might seem like a lie if you view the index as a place to record how
we got to the current state rather than a way to help users resolve
conflicts and update state, but it is certainly far more convenient for
the user to work with.  Follow suit with directory/file conflicts.


***************************************************************************

WIP/RFC/PATCH: Modifications to handling of non-textual file merge conflicts

== Summary ==

For non-textual conflicts, I would like to provide additional information
in the working copy in the form of additional conflict markers and
explanatory text stating what type of non-textual conflict was involved.
This should
  * Make it clearer to users what conflicts they are dealing with and why
  * Enable new features like Thomas Rast' old remerge-diff proposal[1]

[1] https://public-inbox.org/git/cover.1409860234.git.tr@thomasrast.ch/

If this sounds rather imprecise, concrete examples are provided in the
next section of this email.  If this change sounds surprising or
non-intuitive, more detailed rationale motivating this change (which is
admittedly slightly non-obvious) can be found in the remainder of this
email.

== Examples of Proposal ==

There are two basic types of changes at play here, each best shown with a
representative example:

1) Representative example: A modify/delete conflict; the path in question
in the working tree would have conflict information at the top of the file
followed by the normal file contents; thus it could be of the form:

    <<<<<<<< HEAD
    Conflict hint: This block of text was not part of the original
    branch; it serves instead to hint about non-textual conflicts:
      MODIFY/DELETE: path foo modified in HEAD and deleted in BRANCH
    ========
    Conflict hint: This block of text was not part of the original
    branch; it serves instead to hint about non-textual conflicts:
      MODIFY/DELETE: path foo modified in HEAD and deleted in BRANCH
    >>>>>>>> BRANCH
    Lorem ipsum dolor sit amet, consectetuer sadipscing elitr,
    sed diam nonumy eirmod tempor invidunt ut labore et dolore
    magna aliquyam erat, sed diam voluptua. At vero eos et
    accusam et justo duo dolores et ea rebum. Stet clita kasd
    gubergren, no sea takimata sanctus est Lorem ipsum dolor
    sit amet.

Alternative ideas for handling the explanatory text here are welcome.  I
chose to use identical text on both sides of the conflict in an attempt
to highlight that this isn't a normal textual conflict and the text isn't
meant to be part of the file.

This type of example could apply for each of the following types of
conflicts:
  * modify/delete
  * rename/delete
  * directory/file
  * submodule/file
  * symlink/file
  * rename/rename(1to2)
  * executable mode conflict (i.e. 100644 vs. 100755 mode; could come
    from add/add or modify/delete or rename/delete)

It could also be used for the following types of conflicts to help
differentiate between it and other conflict types:
  * add/add
  * rename/add[/delete]
  * rename/rename(2to1)[/delete[/delete]]
  * rename/rename(1to2)/add[/add]

However, any of the types above would be inappropriate if the regular
file(s) in question were binary; in those cases, they'd actually fall
into category two:


2) Representative example: A binary edit/edit conflict.  In this case,
it would be inappropriate to put the conflict markers inside the
binary file.  Instead, we create another file (e.g. path~CONFLICTS)
and put conflict markers in it:

    <<<<<<<< HEAD
    Conflict hint: This block of text was not part of the original
    branch; it serves instead to hint about non-textual conflicts:
      BINARY conflict: path foo modified in both branches
    ========
    Conflict hint: This block of text was not part of the original
    branch; it serves instead to hint about non-textual conflicts:
      BINARY conflict: path foo modified in both branches
    >>>>>>>> BRANCH

This file would also be added to the index at stage 1 (so that 'git merge
--abort' would clean this file out instead of leaving it around untracked,
and also because 'git status' would report "deleted in both" which seems
reasonable).

This type of example could apply for each of the following types of
conflicts:
  * binary edit/edit
  * any of the conflicts from type 1 when binary files are involved
  * symlink edit/edit (or add/add)
  * symlink/submodule
  * symlink/directory
  * directory/submodule
  * submodule/submodule

It could also apply to the following new corner case conflict types from
directory rename detection:
  * N-way colliding paths (N>=2) due to directory renames
  * directory rename split; half renamed to one directory and half to another


== Motivation, part 1: Problem statement ==

When conflicts arise we need ways to inform the user of the existence of
the conflicts and their nature.  For textual conflicts with regular files,
we have a simple way of doing this: inserting conflict markers into the
relevant region of the file with both conflicting versions present.
Importantly, this representation of the conflict is present in the working
copy.

For other types of conflicts (path-based or non-regular files), we often
provide no hint in the working copy about either the existence or the
nature of the conflict.  I think this is suboptimal from a users'
point-of-view, and is also limiting some feature development.

== Motivation, part 2: Current non-textual conflict hints ==

For non-textual conflicts, the hints git currently gives the user come in
two forms: messages printed during the merge, and higher order stages in
the index.  Both have some downsides.

For large repos, conflict messages ("e.g. CONFLICT(modify/delete): ...")
printed during the merge can easily be "lost in the noise" and might even
be inaccessible depending on the terminal scrollback buffer size.
Further, as the user begins resolving conflicts in that terminal, it
becomes harder and harder to find the original conflict messages for the
remaining paths.

While higher order stages in the index can be helpful, there are many more
conflict types than there are permutations of higher order stages.  To
name just one example, if all three higher order stages exist, what type
of conflict is it?  It could be an edit/edit conflict, or a
rename/add/delete conflict, or even a file from a directory/file conflict
if that file was involved in a rename.

== Motivation, part 3: Disappearing conflict hints ==

I want to revive Thomas Rast' remerge-diff feature proposal.  To implement
that feature, he essentially does an auto-merge of the parent commits and
records a resulting tree.  That tree includes conflict information, namely
in the form of files that have conflict markers in them.  He then diffs
this auto-merged tree to the actual tree of the merge commit.

I like the idea of an auto-merge tree with conflict information, but note
that this means printed conflict messages and higher order index entries
will be _completely_ lost, making it important that there be a way of
storing hints about conflicts in the working tree.

(Side note: Thomas' old proposal partially address this; he takes paths
that only had either a stage 2 or 3 entry and does a two-way diff with an
empty file.  That is a very reasonable first cut, but it misses lots of
information.  For example, binary conflicts and mode conflicts would
essentially be ignored.  Differentation between conflict types -- which
may be important or helpful to users trying to understand what happened --
would be lost.)
